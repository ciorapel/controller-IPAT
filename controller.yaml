substitutions:
  device_name: "heating_controller"
  # Inputuri de termostate
  thermostat_pin_1: "D1"
  thermostat_pin_2: "D2"
  thermostat_pin_3: "D5"
  thermostat_pin_4: "D6"
  thermostat_pin_5: "D7"
  thermostat_pin_6: "D0"

  # Releele fizice asociate termostatelor
  relay_pin_1: "D3"
  relay_pin_2: "D4"
  relay_pin_3: "RX"   # cautați să nu folosiți serial daca o folosiți pentru debug
  relay_pin_4: "TX"
  relay_pin_5: "D8"
  relay_pin_6: "D2"   # ATENȚIE: schimbă dacă folosește D2 ca termostat!

  boiler_relay_pin: "D9"  # verifică dacă pinul există pe placa ta

esphome:
  name: ${device_name}
  platform: ESP8266
  board: d1_mini

wifi:
  ssid: "YOUR_SSID"
  password: "YOUR_PASS"
  ap:
    ssid: "${device_name}_AP"
    password: "12345678"

logger:
  level: DEBUG

api:
  reboot_timeout: 0s
  on_client_connected:
    then:
      - lambda: |-
          ESP_LOGI("api", "Home Assistant connected");
  on_client_disconnected:
    then:
      - lambda: |-
          ESP_LOGI("api", "Home Assistant disconnected");

ota:

watchdog:
  timeout: 15s

# --------------------
# GLOBALS (persistente acolo unde are sens)
# --------------------
globals:
  - id: control_mode         # 0 = Auto, 1 = Manual
    type: int
    restore_value: yes
    initial_value: '0'

  - id: heating_delay_ms     # delay (ms) -> set din HA (secunde * 1000)
    type: unsigned long
    restore_value: yes
    initial_value: '180000'   # 180 s

  - id: debounce_s           # debounce (s) pentru termostate (config din HA)
    type: int
    restore_value: yes
    initial_value: '30'

  - id: thermostat_raw_last_state
    type: bool[6]
    restore_value: no
    initial_value: '{false,false,false,false,false,false}'

  - id: thermostat_raw_last_change
    type: unsigned long[6]
    restore_value: no
    initial_value: '{0,0,0,0,0,0}'

  - id: thermostat_request   # starea debounced a termostatelor (input local)
    type: bool[6]
    restore_value: yes
    initial_value: '{false,false,false,false,false,false}'

  - id: ha_request           # cererile din HA (virtual switches)
    type: bool[6]
    restore_value: yes
    initial_value: '{false,false,false,false,false,false}'

  - id: effective_request    # ce se aplica (in Auto -> termostat_request, in Manual -> ha_request)
    type: bool[6]
    restore_value: no
    initial_value: '{false,false,false,false,false,false}'

  - id: zone_start_time      # timestamp (ms) cand zona a devenit efectiv ON (real active)
    type: unsigned long[6]
    restore_value: yes
    initial_value: '{0,0,0,0,0,0}'

  - id: zone_force_keep_until   # pana la timestamp (ms) mentinem deschisa zona (protectie)
    type: unsigned long[6]
    restore_value: yes
    initial_value: '{0,0,0,0,0,0}'

  - id: prev_effective_request
    type: bool[6]
    restore_value: no
    initial_value: '{false,false,false,false,false,false}'

  - id: boiler_pending
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: boiler_active
    type: bool
    restore_value: yes
    initial_value: 'false'

  - id: boiler_pending_since
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: prev_any_real_active
    type: bool
    restore_value: no
    initial_value: 'false'

# --------------------
# INPUTS: raw thermostats (internal = true -> nu sunt expuse direct)
# Debounce se face software în interval lambda (pentru a fi configurabil din HA)
# --------------------
binary_sensor:
  - platform: gpio
    pin: ${thermostat_pin_1}
    id: ts_raw_1
    internal: true
  - platform: gpio
    pin: ${thermostat_pin_2}
    id: ts_raw_2
    internal: true
  - platform: gpio
    pin: ${thermostat_pin_3}
    id: ts_raw_3
    internal: true
  - platform: gpio
    pin: ${thermostat_pin_4}
    id: ts_raw_4
    internal: true
  - platform: gpio
    pin: ${thermostat_pin_5}
    id: ts_raw_5
    internal: true
  - platform: gpio
    pin: ${thermostat_pin_6}
    id: ts_raw_6
    internal: true
  - platform: template
    name: "Boiler Pending"
    lambda: return id(boiler_pending);

# --------------------
# PHYSICAL RELAYS (nu sunt expuse direct)
# --------------------
switch:
  - platform: gpio
    pin: ${relay_pin_1}
    id: phys_relay_zone_1
    restore_mode: ALWAYS_OFF
  - platform: gpio
    pin: ${relay_pin_2}
    id: phys_relay_zone_2
    restore_mode: ALWAYS_OFF
  - platform: gpio
    pin: ${relay_pin_3}
    id: phys_relay_zone_3
    restore_mode: ALWAYS_OFF
  - platform: gpio
    pin: ${relay_pin_4}
    id: phys_relay_zone_4
    restore_mode: ALWAYS_OFF
  - platform: gpio
    pin: ${relay_pin_5}
    id: phys_relay_zone_5
    restore_mode: ALWAYS_OFF
  - platform: gpio
    pin: ${relay_pin_6}
    id: phys_relay_zone_6
    restore_mode: ALWAYS_OFF

  - platform: gpio
    pin: ${boiler_relay_pin}
    id: phys_relay_boiler
    name: "Physical Boiler Relay"
    restore_mode: ALWAYS_OFF

# --------------------
# VIRTUAL SWITCHES (expuse in HA) - inhibate în Auto
# Acestea seteză ha_request[] doar în modul Manual
# lambda returnează starea care va fi afișată în HA
# --------------------
  - platform: template
    name: "Virtual Zone 1"
    id: v_zone_1
    optimistic: false
    lambda: |-
      if (id(control_mode) == 0) return false; // Auto: afișăm OFF (inhibit)
      return id(ha_request)[0];
    turn_on_action:
      - lambda: |-
          if (id(control_mode) == 1) {
            id(ha_request)[0] = true;
            ESP_LOGI("HA", "Virtual Zone 1 ON (manual)");
          }
    turn_off_action:
      - lambda: |-
          if (id(control_mode) == 1) {
            id(ha_request)[0] = false;
            ESP_LOGI("HA", "Virtual Zone 1 OFF (manual)");
          }

  - platform: template
    name: "Virtual Zone 2"
    id: v_zone_2
    optimistic: false
    lambda: |-
      if (id(control_mode) == 0) return false;
      return id(ha_request)[1];
    turn_on_action:
      - lambda: |-
          if (id(control_mode) == 1) {
            id(ha_request)[1] = true;
            ESP_LOGI("HA", "Virtual Zone 2 ON (manual)");
          }
    turn_off_action:
      - lambda: |-
          if (id(control_mode) == 1) {
            id(ha_request)[1] = false;
            ESP_LOGI("HA", "Virtual Zone 2 OFF (manual)");
          }

  - platform: template
    name: "Virtual Zone 3"
    id: v_zone_3
    optimistic: false
    lambda: |-
      if (id(control_mode) == 0) return false;
      return id(ha_request)[2];
    turn_on_action:
      - lambda: |-
          if (id(control_mode) == 1) {
            id(ha_request)[2] = true;
            ESP_LOGI("HA", "Virtual Zone 3 ON (manual)");
          }
    turn_off_action:
      - lambda: |-
          if (id(control_mode) == 1) {
            id(ha_request)[2] = false;
            ESP_LOGI("HA", "Virtual Zone 3 OFF (manual)");
          }

  - platform: template
    name: "Virtual Zone 4"
    id: v_zone_4
    optimistic: false
    lambda: |-
      if (id(control_mode) == 0) return false;
      return id(ha_request)[3];
    turn_on_action:
      - lambda: |-
          if (id(control_mode) == 1) {
            id(ha_request)[3] = true;
            ESP_LOGI("HA", "Virtual Zone 4 ON (manual)");
          }
    turn_off_action:
      - lambda: |-
          if (id(control_mode) == 1) {
            id(ha_request)[3] = false;
            ESP_LOGI("HA", "Virtual Zone 4 OFF (manual)");
          }

  - platform: template
    name: "Virtual Zone 5"
    id: v_zone_5
    optimistic: false
    lambda: |-
      if (id(control_mode) == 0) return false;
      return id(ha_request)[4];
    turn_on_action:
      - lambda: |-
          if (id(control_mode) == 1) {
            id(ha_request)[4] = true;
            ESP_LOGI("HA", "Virtual Zone 5 ON (manual)");
          }
    turn_off_action:
      - lambda: |-
          if (id(control_mode) == 1) {
            id(ha_request)[4] = false;
            ESP_LOGI("HA", "Virtual Zone 5 OFF (manual)");
          }

  - platform: template
    name: "Virtual Zone 6"
    id: v_zone_6
    optimistic: false
    lambda: |-
      if (id(control_mode) == 0) return false;
      return id(ha_request)[5];
    turn_on_action:
      - lambda: |-
          if (id(control_mode) == 1) {
            id(ha_request)[5] = true;
            ESP_LOGI("HA", "Virtual Zone 6 ON (manual)");
          }
    turn_off_action:
      - lambda: |-
          if (id(control_mode) == 1) {
            id(ha_request)[5] = false;
            ESP_LOGI("HA", "Virtual Zone 6 OFF (manual)");
          }

  - platform: template
    name: "Virtual Boiler"
    id: v_boiler
    optimistic: false
    lambda: |-
      // Afișăm starea reală (boiler_active) indiferent de mod
      return id(boiler_active);
    turn_on_action:
      - lambda: |-
          if (id(control_mode) == 1) {
            // manual: permite pornirea imediată a centralei
            id(boiler_pending) = false;
            id(boiler_active) = true;
            id(phys_relay_boiler).turn_on();
            ESP_LOGI("HA", "Boiler pornit manual din HA");
          }
    turn_off_action:
      - lambda: |-
          if (id(control_mode) == 1) {
            id(boiler_pending) = false;
            id(boiler_active) = false;
            id(phys_relay_boiler).turn_off();
            ESP_LOGI("HA", "Boiler oprit manual din HA");
          }

# --------------------
# Select + Number in HA pentru mod și relee
# --------------------
select:
  - platform: template
    name: "Control Mode"
    id: control_mode_select
    optimistic: true
    initial_option: "Auto"
    options:
      - "Auto"
      - "Manual"
    set_action:
      - lambda: |-
          if (x == "Auto") {
            id(control_mode) = 0;
            ESP_LOGI("main", "Control mode set to AUTO via HA");
          } else {
            id(control_mode) = 1;
            ESP_LOGI("main", "Control mode set to MANUAL via HA");
          }

number:
  - platform: template
    name: "Activation Delay (s)"
    id: activation_delay_number
    min_value: 0
    max_value: 600
    step: 10
    optimistic: true
    set_action:
      - lambda: |-
          id(heating_delay_ms) = (unsigned long)(x * 1000);
          ESP_LOGI("main", "Activation delay changed via HA: %d s", (int)x);

  - platform: template
    name: "Debounce (s)"
    id: debounce_number
    min_value: 0
    max_value: 300
    step: 5
    optimistic: true
    set_action:
      - lambda: |-
          id(debounce_s) = (int)x;
          ESP_LOGI("main", "Debounce time changed via HA: %d s", (int)x);

# --------------------
# Senzor de status petntru disponibilitate. Devine ”unavailable” când ESP se deconectează
# --------------------
binary_sensor:
  - platform: status
    name: "Heating Controller Online"

# --------------------
# Bucla de control principală: rulează la fiecare secundă, implementează:
# - debounce pentru termostate brute (configurabile)
# - selecție effective_request (Auto/Manual)
# - protecție: forțează menținerea zonelor deschise dacă este necesar
# - logica pornire/așteptare/oprire centrală
# - închidere automată a zonelor forțate la expirarea protecției
# - înregistrarea evenimentelor cheie
# --------------------
interval:
  - interval: 1s
    then:
      - lambda: |-
          const unsigned long now = millis();
          const unsigned long debounce_ms = (unsigned long)id(debounce_s) * 1000UL;
          const unsigned long delay_ms = (unsigned long)id(heating_delay_ms);

          // --- 1) READ raw inputs and apply software debounce ---
          // helper lambda to get raw state by index
          auto read_raw = [&](int idx)->bool {
            switch (idx) {
              case 0: return id(ts_raw_1).state;
              case 1: return id(ts_raw_2).state;
              case 2: return id(ts_raw_3).state;
              case 3: return id(ts_raw_4).state;
              case 4: return id(ts_raw_5).state;
              case 5: return id(ts_raw_6).state;
            }
            return false;
          };

          for (int i = 0; i < 6; i++) {
            bool raw = read_raw(i);
            // if changed since last observed sample, reset timer
            if (raw != id(thermostat_raw_last_state)[i]) {
              id(thermostat_raw_last_state)[i] = raw;
              id(thermostat_raw_last_change)[i] = now;
            } else {
              // stable reading for some time -> if beyond debounce_ms, update thermostat_request
              if ((unsigned long)(now - id(thermostat_raw_last_change)[i]) >= debounce_ms) {
                if (id(thermostat_request)[i] != raw) {
                  id(thermostat_request)[i] = raw;
                  if (raw) {
                    ESP_LOGI("debounce", "Thermostat %d debounced -> ON (raw stable %lu ms)", i+1, (unsigned long)(now - id(thermostat_raw_last_change)[i]));
                  } else {
                    ESP_LOGI("debounce", "Thermostat %d debounced -> OFF (raw stable %lu ms)", i+1, (unsigned long)(now - id(thermostat_raw_last_change)[i]));
                  }
                }
              }
            }
          }

          // --- 2) Build effective_request[] depending on mode ---
          for (int i = 0; i < 6; i++) {
            if (id(control_mode) == 1) {
              // Manual mode: HA virtual switches control requests
              id(effective_request)[i] = id(ha_request)[i];
            } else {
              // Auto mode: thermostats control requests
              id(effective_request)[i] = id(thermostat_request)[i];
            }
          }

          // --- 3) Determine will-be-real-active state (consider forced keeps) ---
          bool any_real_active = false;
          int real_active_count = 0;
          int last_real_idx = -1;
          for (int i = 0; i < 6; i++) {
            bool will_be = id(effective_request)[i] || (id(zone_force_keep_until)[i] > now);
            if (will_be) {
              any_real_active = true;
              real_active_count++;
              last_real_idx = i;
            }
          }

          // --- 4) Start times management ---
          // set zone_start_time when a zone becomes real-active (and was not before)
          for (int i = 0; i < 6; i++) {
            bool was_real_before = id(prev_effective_request)[i] || (id(zone_force_keep_until)[i] > now);
            bool now_real = id(effective_request)[i] || (id(zone_force_keep_until)[i] > now);
            if (now_real && !was_real_before) {
              // zone just became real active
              id(zone_start_time)[i] = now;
              ESP_LOGI("zones", "Zone %d became real-active at %lu", i+1, now);
            }
            if (!now_real && ! (id(zone_force_keep_until)[i] > now) ) {
              // zone not real active and not forced => reset its start time (so future activations start fresh)
              if (id(zone_start_time)[i] != 0) {
                id(zone_start_time)[i] = 0;
                ESP_LOGI("zones", "Zone %d start_time reset", i+1);
              }
            }
          }

          // --- 5) Protection on STOP: detect zones that just requested STOP and may need to be forced ---
          for (int i = 0; i < 6; i++) {
            bool just_stopped = (id(prev_effective_request)[i] && !id(effective_request)[i]);
            if (just_stopped) {
              // compute how many would remain active if zone i stops now
              int would_remain = 0;
              int remain_idx = -1;
              for (int j = 0; j < 6; j++) {
                if (j == i) continue;
                bool j_active = id(effective_request)[j] || (id(zone_force_keep_until)[j] > now);
                if (j_active) { would_remain++; remain_idx = j; }
              }
              if (would_remain == 1) {
                // only one zone would remain -> check its runtime
                unsigned long start = id(zone_start_time)[remain_idx];
                unsigned long elapsed = 0;
                if (start > 0) elapsed = now - start;
                if (elapsed < delay_ms) {
                  // force keep zone i until remain_idx passes delay
                  id(zone_force_keep_until)[i] = id(zone_start_time)[remain_idx] + delay_ms;
                  ESP_LOGI("protect", "Zone %d STOP requested but would leave zone %d alone (elapsed %lu ms < %lu ms). Forcing zone %d until %lu",
                    i+1, remain_idx+1, elapsed, delay_ms, i+1, (unsigned long)id(zone_force_keep_until)[i]);
                }
              }
            }
          }

          // --- 6) Apply real states to physical relays ---
          for (int i = 0; i < 6; i++) {
            bool real = id(effective_request)[i] || (id(zone_force_keep_until)[i] > now);
            switch (i) {
              case 0:
                if (real) id(phys_relay_zone_1).turn_on(); else id(phys_relay_zone_1).turn_off();
                break;
              case 1:
                if (real) id(phys_relay_zone_2).turn_on(); else id(phys_relay_zone_2).turn_off();
                break;
              case 2:
                if (real) id(phys_relay_zone_3).turn_on(); else id(phys_relay_zone_3).turn_off();
                break;
              case 3:
                if (real) id(phys_relay_zone_4).turn_on(); else id(phys_relay_zone_4).turn_off();
                break;
              case 4:
                if (real) id(phys_relay_zone_5).turn_on(); else id(phys_relay_zone_5).turn_off();
                break;
              case 5:
                if (real) id(phys_relay_zone_6).turn_on(); else id(phys_relay_zone_6).turn_off();
                break;
            }
          }

          // --- 7) Boiler/pump logic (delay on start, immediate off) ---
          if (any_real_active) {
            // if previously no real active, start pending window
            if (!id(prev_any_real_active) && !id(boiler_active)) {
              // start pending
              id(boiler_pending) = true;
              id(boiler_pending_since) = now;
              ESP_LOGI("boiler", "Boiler pending START (zones became active) at %lu", now);
            }

            if (id(boiler_pending) && !id(boiler_active)) {
              if ((unsigned long)(now - id(boiler_pending_since)) >= delay_ms) {
                // pending expired -> actually start boiler
                id(boiler_active) = true;
                id(boiler_pending) = false;
                id(phys_relay_boiler).turn_on();
                ESP_LOGI("boiler", "Boiler ACTIVATED after delay at %lu", now);
              } else {
                // still pending
                unsigned long remaining = delay_ms - (unsigned long)(now - id(boiler_pending_since));
                ESP_LOGD("boiler", "Boiler pending... %lu ms remaining", remaining);
              }
            }
            // if already active -> keep it on
          } else {
            // no zones real active -> immediate stop
            if (id(boiler_active) || id(boiler_pending)) {
              id(phys_relay_boiler).turn_off();
              id(boiler_active) = false;
              id(boiler_pending) = false;
              id(boiler_pending_since) = 0;
              ESP_LOGI("boiler", "No zones active -> Boiler & Pump stopped immediately at %lu", now);
            }
          }

          // --- 8) Clear expired zone_force_keep_until and auto-close forced zones on expiry ---
          for (int i = 0; i < 6; i++) {
            if (id(zone_force_keep_until)[i] > 0 && id(zone_force_keep_until)[i] <= now) {
              id(zone_force_keep_until)[i] = 0;
              ESP_LOGI("protect", "Force-keep for zone %d expired at %lu -> zone may now close if not requested", i+1, now);
            }
          }

          // --- 9) Update prev arrays for next iteration ---
          for (int i=0;i<6;i++) {
            id(prev_effective_request)[i] = id(effective_request)[i];
          }
          id(prev_any_real_active) = any_real_active;
