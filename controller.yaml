substitutions:
  device_name: "heating_controller"
  friendly_name: "Heating Controller"
  # Inputuri de termostate (5 zone)
  thermostat_pin_1: "D1"
  thermostat_pin_2: "D2"
  thermostat_pin_3: "D5"
  thermostat_pin_4: "D6"
  thermostat_pin_5: "D7"

  # Releele fizice asociate termostatelor (5 zone)
  relay_pin_1: "D3"
  relay_pin_2: "D4"
  relay_pin_3: "TX"   # cautați să nu folosiți serial dacă o folosiți pentru debug
  relay_pin_4: "RX"
  relay_pin_5: "D8"

  boiler_relay_pin: "D0"  # GPIO16 - perfect pentru centrală
  
esphome:
  name: ${device_name}
  on_boot:
    priority: 600
    then:
      - lambda: |-
          id(heating_delay_ms) = (unsigned long)(id(activation_delay_number).state * 1000);
          ESP_LOGI("main", "Activation delay restored on boot: %d ms", (int)id(heating_delay_ms));

esp8266:
  board: d1_mini
  framework:
    version: recommended

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "${device_name}_AP"
    password: "12345678"

logger:
  level: NONE

api:
  reboot_timeout: 0s
  on_client_connected:
    then:
      - lambda: |-
          ESP_LOGI("api", "Home Assistant connected");
  on_client_disconnected:
    then:
      - lambda: |-
          ESP_LOGI("api", "Home Assistant disconnected");

ota:
  - platform: esphome


# --------------------
# GLOBALS (persistente acolo unde are sens)
# --------------------
globals:
  - id: heating_delay_ms     # delay (ms) -> set din HA (secunde * 1000)
    type: unsigned long
    restore_value: yes
    initial_value: '180000'   # 180 s

  - id: thermostat_request   # starea termostatelor (input local)
    type: bool[5]
    restore_value: yes
    initial_value: '{false,false,false,false,false}'

  - id: ha_request           # cererile din HA (virtual switches)
    type: bool[5]
    restore_value: yes
    initial_value: '{false,false,false,false,false}'

  - id: effective_request    # ce se aplica (in Auto -> thermostat_request, in Manual -> ha_request)
    type: bool[5]
    restore_value: no
    initial_value: '{false,false,false,false,false}'

  - id: zone_start_time      # timestamp (ms) cand zona a devenit efectiv ON (real active)
    type: unsigned long[5]
    restore_value: yes
    initial_value: '{0,0,0,0,0}'

  - id: zone_force_keep_until   # pana la timestamp (ms) mentinem deschisa zona (protectie)
    type: unsigned long[5]
    restore_value: yes
    initial_value: '{0,0,0,0,0}'

  - id: prev_effective_request
    type: bool[5]
    restore_value: no
    initial_value: '{false,false,false,false,false}'

  - id: boiler_pending
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: boiler_active
    type: bool
    restore_value: yes
    initial_value: 'false'

  - id: boiler_pending_since
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: prev_any_real_active
    type: bool
    restore_value: no
    initial_value: 'false'
  
  - id: system_status_text
    type: std::string
    restore_value: no
    initial_value: '"Idle"'
    
# --------------------
# INPUTS: raw thermostats (internal = true -> nu sunt expuse direct)
# --------------------
binary_sensor:
  - platform: gpio
    pin:
      number: ${thermostat_pin_1}
      mode: INPUT_PULLUP
      inverted: true   # dacă logica hardware este astfel
    id: ts_raw_1
    internal: true
  - platform: gpio
    pin:
      number: ${thermostat_pin_2}
      mode: INPUT_PULLUP
      inverted: true   # dacă logica hardware este astfel
    id: ts_raw_2
    internal: true
  - platform: gpio
    pin:
      number: ${thermostat_pin_3}
      mode: INPUT_PULLUP
      inverted: true   # dacă logica hardware este astfel
    id: ts_raw_3
    internal: true
  - platform: gpio
    pin:
      number: ${thermostat_pin_4}
      mode: INPUT_PULLUP
      inverted: true   # dacă logica hardware este astfel
    id: ts_raw_4
    internal: true
  - platform: gpio
    pin:
      number: ${thermostat_pin_5}
      mode: INPUT_PULLUP
      inverted: true   # dacă logica hardware este astfel
    id: ts_raw_5
    internal: true

  - platform: status
    name: "Heating Controller Online"

  - platform: template
    name: "System Heating"
    id: system_heating_binary
    lambda: |-
      return id(boiler_active);
      
  - platform: template  
    name: "System Pending"
    id: system_pending_binary
    lambda: |-
      return id(boiler_pending);
      
  - platform: template
    name: "Any Zone Forced"
    id: any_zone_forced_binary
    lambda: |-
      unsigned long now = millis();
      for (int i = 0; i < 5; i++) {
        if (id(zone_force_keep_until)[i] > now) return true;
      }
      return false;



# --------------------
# PHYSICAL RELAYS (nu sunt expuse direct)
# --------------------
switch:
  - platform: template
    name: "Manual Mode"
    id: manual_mode_switch
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    turn_on_action:
      - lambda: |-
          ESP_LOGI("main", "Control mode set to MANUAL via switch");
    turn_off_action:
      - lambda: |-
          ESP_LOGI("main", "Control mode set to AUTO via switch");
  - platform: gpio
    pin: ${relay_pin_1}
    id: phys_relay_zone_1
    inverted: true
    restore_mode: ALWAYS_OFF
  - platform: gpio
    pin: ${relay_pin_2}
    id: phys_relay_zone_2
    inverted: true
    restore_mode: ALWAYS_OFF
  - platform: gpio
    pin: ${relay_pin_3}
    id: phys_relay_zone_3
    inverted: true
    restore_mode: ALWAYS_OFF
  - platform: gpio
    pin: ${relay_pin_4}
    id: phys_relay_zone_4
    inverted: true
    restore_mode: ALWAYS_OFF
  - platform: gpio
    pin: ${relay_pin_5}
    id: phys_relay_zone_5
    inverted: true
    restore_mode: ALWAYS_OFF

  - platform: gpio
    pin: ${boiler_relay_pin}
    id: phys_relay_boiler
    internal: true
    inverted: true
    name: "Physical Boiler Relay"
    restore_mode: ALWAYS_OFF

# --------------------
# VIRTUAL SWITCHES (expuse in HA) - inhibate în Auto
# --------------------
  - platform: template
    name: "Virtual Zone 1"
    id: v_zone_1
    optimistic: false
    lambda: |-
      if (!id(manual_mode_switch).state) return false; // Auto: afișăm OFF (inhibit)
      return id(ha_request)[0];
    turn_on_action:
      - lambda: |-
          if (id(manual_mode_switch).state){
            id(ha_request)[0] = true;
            ESP_LOGI("HA", "Virtual Zone 1 ON (manual)");
          }
    turn_off_action:
      - lambda: |-
          if (id(manual_mode_switch).state){
            id(ha_request)[0] = false;
            ESP_LOGI("HA", "Virtual Zone 1 OFF (manual)");
          }

  - platform: template
    name: "Virtual Zone 2"
    id: v_zone_2
    optimistic: false
    lambda: |-
      if (!id(manual_mode_switch).state)return false;
      return id(ha_request)[1];
    turn_on_action:
      - lambda: |-
          if (id(manual_mode_switch).state){
            id(ha_request)[1] = true;
            ESP_LOGI("HA", "Virtual Zone 2 ON (manual)");
          }
    turn_off_action:
      - lambda: |-
          if (id(manual_mode_switch).state){
            id(ha_request)[1] = false;
            ESP_LOGI("HA", "Virtual Zone 2 OFF (manual)");
          }

  - platform: template
    name: "Virtual Zone 3"
    id: v_zone_3
    optimistic: false
    lambda: |-
      if (!id(manual_mode_switch).state)return false;
      return id(ha_request)[2];
    turn_on_action:
      - lambda: |-
          if (id(manual_mode_switch).state){
            id(ha_request)[2] = true;
            ESP_LOGI("HA", "Virtual Zone 3 ON (manual)");
          }
    turn_off_action:
      - lambda: |-
          if (id(manual_mode_switch).state){
            id(ha_request)[2] = false;
            ESP_LOGI("HA", "Virtual Zone 3 OFF (manual)");
          }

  - platform: template
    name: "Virtual Zone 4"
    id: v_zone_4
    optimistic: false
    lambda: |-
      if (!id(manual_mode_switch).state)return false;
      return id(ha_request)[3];
    turn_on_action:
      - lambda: |-
          if (id(manual_mode_switch).state){
            id(ha_request)[3] = true;
            ESP_LOGI("HA", "Virtual Zone 4 ON (manual)");
          }
    turn_off_action:
      - lambda: |-
          if (id(manual_mode_switch).state){
            id(ha_request)[3] = false;
            ESP_LOGI("HA", "Virtual Zone 4 OFF (manual)");
          }

  - platform: template
    name: "Virtual Zone 5"
    id: v_zone_5
    optimistic: false
    lambda: |-
      if (!id(manual_mode_switch).state)return false;
      return id(ha_request)[4];
    turn_on_action:
      - lambda: |-
          if (id(manual_mode_switch).state){
            id(ha_request)[4] = true;
            ESP_LOGI("HA", "Virtual Zone 5 ON (manual)");
          }
    turn_off_action:
      - lambda: |-
          if (id(manual_mode_switch).state){
            id(ha_request)[4] = false;
            ESP_LOGI("HA", "Virtual Zone 5 OFF (manual)");
          }

# --------------------
# Select + Number in HA pentru mod și parametri
# --------------------
number:
  - platform: template
    name: "Activation Delay (s)"
    id: activation_delay_number
    min_value: 0
    max_value: 600
    step: 10
    optimistic: true
    restore_value: yes
    set_action:
      - lambda: |-
          id(heating_delay_ms) = (unsigned long)(x * 1000);
          ESP_LOGI("main", "Activation delay changed via HA: %d s", (int)x);

# --------------------
# TEXT SENSORS - Status și informații
# --------------------
text_sensor:
  - platform: template
    name: "Thermostat 1"
    id: ts1_status
    update_interval: 1s
    lambda: |-
      return std::string(id(thermostat_request)[0] ? "Heating" : "Idle");

  - platform: template
    name: "Thermostat 2"
    id: ts2_status
    update_interval: 1s
    lambda: |-
      return std::string(id(ts_raw_2).state ? "Heating" : "Idle");

  - platform: template
    name: "Thermostat 3"
    id: ts3_status
    update_interval: 1s
    lambda: |-
      return std::string(id(thermostat_request)[2] ? "Heating" : "Idle");

  - platform: template
    name: "Thermostat 4"
    id: ts4_status
    update_interval: 1s
    lambda: |-
      return std::string(id(thermostat_request)[3] ? "Heating" : "Idle");

  - platform: template
    name: "Thermostat 5"
    id: ts5_status
    update_interval: 1s
    lambda: |-
      return std::string(id(thermostat_request)[4] ? "Heating" : "Idle");
  - platform: template
    name: "System Status"
    id: system_status_sensor
    lambda: |-
      return id(system_status_text);
    update_interval: 1s
    
  - platform: template
    name: "Controller Mode"
    lambda: |-
      return id(manual_mode_switch).state ? std::string("Manual") : std::string("Auto");
    update_interval: 1s

# --------------------
# SENSORS numerici - Timeri și statistici
# --------------------
sensor:
  - platform: template
    name: "Active Zones"
    id: active_zones_count
    unit_of_measurement: "zones"
    accuracy_decimals: 0

  - platform: template
    name: "Forced Zones"
    id: forced_zones_count
    unit_of_measurement: "zones"
    accuracy_decimals: 0
    
  - platform: template
    name: "Boiler Delay Countdown"
    id: boiler_delay_countdown
    unit_of_measurement: "s"
    accuracy_decimals: 0
    lambda: |-
      if (!id(boiler_pending)) return 0;
      unsigned long elapsed = millis() - id(boiler_pending_since);
      unsigned long remaining = id(heating_delay_ms) > elapsed ? 
        (id(heating_delay_ms) - elapsed) / 1000 : 0;
      return (float)remaining;
    update_interval: 1s


# --------------------
# BUTTONS pentru comenzi
# --------------------
button:
  - platform: template
    name: "Force Stop All Zones"
    on_press:
      - lambda: |-
          if (id(manual_mode_switch).state){
            for (int i = 0; i < 5; i++) {
              id(ha_request)[i] = false;
            }
            ESP_LOGI("manual", "All virtual zones turned OFF via force stop");
          }
          for (int i = 0; i < 5; i++) {
            id(zone_force_keep_until)[i] = 0;
          }
          ESP_LOGI("force", "All zone force-keeps cleared");

  - platform: restart
    name: "Restart Controller"

# --------------------
# BUCLA PRINCIPALĂ DE CONTROL - 5 ZONE
# --------------------
interval:
  - interval: 1s
    then:
      - lambda: |-
          const unsigned long now = millis();
          const unsigned long delay_ms = (unsigned long)id(heating_delay_ms);
          // Actualizează direct starea termostatelor fără debounce
          id(thermostat_request)[0] = id(ts_raw_1).state;
          id(thermostat_request)[1] = id(ts_raw_2).state;
          id(thermostat_request)[2] = id(ts_raw_3).state;
          id(thermostat_request)[3] = id(ts_raw_4).state;
          id(thermostat_request)[4] = id(ts_raw_5).state;

          // --- 2) Build effective_request[] depending on mode ---
          for (int i = 0; i < 5; i++) {
            if (id(manual_mode_switch).state){
              id(effective_request)[i] = id(ha_request)[i];
            } else {
              id(effective_request)[i] = id(thermostat_request)[i];
            }
          }

          // --- 3) Determine will-be-real-active state ---
          bool any_real_active = false;
          for (int i = 0; i < 5; i++) {
            bool will_be = id(effective_request)[i] || (id(zone_force_keep_until)[i] > now);
            if (will_be) {
              any_real_active = true;
              break;
            }
          }

          // --- 4) Start times management ---
          for (int i = 0; i < 5; i++) {
            bool was_real_before = id(prev_effective_request)[i] || (id(zone_force_keep_until)[i] > now);
            bool now_real = id(effective_request)[i] || (id(zone_force_keep_until)[i] > now);
            if (now_real && !was_real_before) {
              id(zone_start_time)[i] = now;
              ESP_LOGI("zones", "Zone %d became real-active", i+1);
            }
            if (!now_real && !(id(zone_force_keep_until)[i] > now)) {
              if (id(zone_start_time)[i] != 0) {
                id(zone_start_time)[i] = 0;
              }
            }
          }

          // --- 5) Protection on STOP ---
          for (int i = 0; i < 5; i++) {
            bool just_stopped = (id(prev_effective_request)[i] && !id(effective_request)[i]);
            if (just_stopped) {
              int would_remain = 0;
              int remain_idx = -1;
              for (int j = 0; j < 5; j++) {
                if (j == i) continue;
                bool j_active = id(effective_request)[j] || (id(zone_force_keep_until)[j] > now);
                if (j_active) { would_remain++; remain_idx = j; }
              }
              if (would_remain == 1) {
                unsigned long start = id(zone_start_time)[remain_idx];
                unsigned long elapsed = 0;
                if (start > 0) elapsed = now - start;
                if (elapsed < delay_ms) {
                  id(zone_force_keep_until)[i] = id(zone_start_time)[remain_idx] + delay_ms;
                  ESP_LOGI("protect", "Zone %d forced to stay on for protection", i+1);
                }
              }
            }
          }

          // --- 6) Apply real states to physical relays ---
          for (int i = 0; i < 5; i++) {
            bool real = id(effective_request)[i] || (id(zone_force_keep_until)[i] > now);
            switch (i) {
              case 0:
                if (real) id(phys_relay_zone_1).turn_on(); else id(phys_relay_zone_1).turn_off();
                break;
              case 1:
                if (real) id(phys_relay_zone_2).turn_on(); else id(phys_relay_zone_2).turn_off();
                break;
              case 2:
                if (real) id(phys_relay_zone_3).turn_on(); else id(phys_relay_zone_3).turn_off();
                break;
              case 3:
                if (real) id(phys_relay_zone_4).turn_on(); else id(phys_relay_zone_4).turn_off();
                break;
              case 4:
                if (real) id(phys_relay_zone_5).turn_on(); else id(phys_relay_zone_5).turn_off();
                break;
            }
          }

          // --- 7) Boiler logic ---
          if (any_real_active) {
            if (!id(prev_any_real_active) && !id(boiler_active)) {
              id(boiler_pending) = true;
              id(boiler_pending_since) = now;
              ESP_LOGI("boiler", "Boiler pending START");
            }

            if (id(boiler_pending) && !id(boiler_active)) {
              if ((unsigned long)(now - id(boiler_pending_since)) >= delay_ms) {
                id(boiler_active) = true;
                id(boiler_pending) = false;
                id(phys_relay_boiler).turn_on();
                ESP_LOGI("boiler", "Boiler ACTIVATED after delay");
              }
            }
          } else {
            if (id(boiler_active) || id(boiler_pending)) {
              id(phys_relay_boiler).turn_off();
              id(boiler_active) = false;
              id(boiler_pending) = false;
              id(boiler_pending_since) = 0;
              ESP_LOGI("boiler", "Boiler stopped - no zones active");
            }
          }

          // --- 8) Clear expired zone force keeps ---
          for (int i = 0; i < 5; i++) {
            if (id(zone_force_keep_until)[i] > 0 && id(zone_force_keep_until)[i] <= now) {
              id(zone_force_keep_until)[i] = 0;
              ESP_LOGI("protect", "Force-keep for zone %d expired", i+1);
            }
          }

          // --- 9) Update prev arrays ---
          for (int i=0;i<5;i++) {
            id(prev_effective_request)[i] = id(effective_request)[i];
          }
          id(prev_any_real_active) = any_real_active;

          // Build status text
          if (id(boiler_pending)) {
            id(system_status_text) = "Power-on delay";
          } else if (id(boiler_active)) {
            id(system_status_text) = "Heating active";
          } else {
            id(system_status_text) = "Idle";
          }
          
          // Build zones text
          std::string active_zones = "";
          std::string forced_zones = "";
          int active_count = 0;
          int forced_count = 0;
          
          for (int i = 0; i < 5; i++) {
            bool is_requested = id(effective_request)[i];
            bool is_forced = (id(zone_force_keep_until)[i] > now);
            bool is_active = is_requested || is_forced;
            
            if (is_active) active_count++;
            if (is_forced) forced_count++;
          }

          id(active_zones_count).publish_state(active_count);
          id(forced_zones_count).publish_state(forced_count);